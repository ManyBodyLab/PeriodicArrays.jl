var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#PeriodicArrays.PeriodicArrays","page":"Reference","title":"PeriodicArrays.PeriodicArrays","text":"Arrays with fixed size and arbitrary boundary conditions.\n\n\n\n\n\n","category":"module"},{"location":"reference/#PeriodicArrays.PeriodicArray","page":"Reference","title":"PeriodicArrays.PeriodicArray","text":"PeriodicArray{T, N, A, F} <: AbstractArray{T, N}\n\nN-dimensional array backed by an AbstractArray{T, N} of type A with fixed size  and periodic indexing as defined by map.\n\narray[index...] == map(array[mod1.(index, size)...], fld.(index .- 1, size)...)\n\n\n\n\n\n","category":"type"},{"location":"reference/#PeriodicArrays.PeriodicArray-Union{Tuple{F}, Tuple{A}, Tuple{N}, Tuple{T}, Tuple{A, F}} where {T, N, A<:AbstractArray{T, N}, F}","page":"Reference","title":"PeriodicArrays.PeriodicArray","text":"PeriodicArray(data, [map])\n\nCreate a PeriodicArray backed by data. map is optional and defaults to the identity map.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PeriodicArrays.PeriodicArray-Union{Tuple{F}, Tuple{T}, Tuple{T, Any}, Tuple{T, Any, F}} where {T, F}","page":"Reference","title":"PeriodicArrays.PeriodicArray","text":"PeriodicArray(def, size, [map])\n\nCreate a PeriodicArray of size size filled with value def. map is optional and defaults to the identity map.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PeriodicArrays.PeriodicMatrix","page":"Reference","title":"PeriodicArrays.PeriodicMatrix","text":"PeriodicMatrix{T, A, F} <: AbstractMatrix{T}\n\nTwo-dimensional array backed by an AbstractArray{T, 2} of type A with fixed size and periodic indexing. Alias for PeriodicArray{T, 2, A, F}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PeriodicArrays.PeriodicVector","page":"Reference","title":"PeriodicArrays.PeriodicVector","text":"PeriodicVector{T, A, F} <: AbstractVector{T}\n\nOne-dimensional array backed by an AbstractArray{T, 1} of type A with fixed size and periodic indexing. Alias for PeriodicArray{T, 1, A, F}.\n\narray[index] == map(array[mod1(index, length)], fld(index - 1, length))\n\n\n\n\n\n","category":"type"},{"location":"index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"#PeriodicArrays.jl","page":"Home","title":"PeriodicArrays.jl","text":"PeriodicArrays.jl adds the PeriodicArray type which can be backed by any AbstractArray. The idea of this package is based on CircularArrays.jl and extends its functionality to support user-defined translation rules for periodic indexing. A PeriodicArray{T,N,A,F} is an AbstractArray{T,N} backed by a data array of type A<:AbstractArray{T,N} and a map f of type F. The map defines how data in out-of-bounds indices is translated to valid indices in the data array.\n\nf can be any callable object (e.g. a function or a struct), which defines\n\nf(x, shift::Vararg{Int,N})\n\nwhere x is an element of the array and shift encodes the unit cell, in which we index. f has to satisfy the following properties, which are not checked at construction time:\n\nThe output type of f has to be the same as the element type of the data array.\nf is invertible with inverse f(x, -shift...), i.e. it satisfies f(f(x, shift...), -shift...) == x.\n\nIf f is not provided, the identity map is used and the PeriodicArray behaves like a CircularArray.\n\nThis package is compatible with OffsetArrays.jl.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The package is not yet registered in the Julia general registry. It can be installed trough the package manager with the following command:\n\npkg> add git@github.com:ManyBodyLab/PeriodicArrays.jl.git","category":"section"},{"location":"#Code-Samples","page":"Home","title":"Code Samples","text":"julia> using PeriodicArrays\njulia> a = PeriodicVector([1,2,3])\njulia> a[0:4]\n5-element PeriodicVector(::Vector{Int64}):\n 3\n 1\n 2\n 3\n 1\njulia> f(x, shift...) = x + 10 * sum(shift)\njulia> a2 = PeriodicArray([1,2,3], f);\njulia> a2[0:4]\n5-element PeriodicVector(::Vector{Int64}):\n -7\n  1\n  2\n  3\n 11\njulia> struct MyTranslator end;\njulia> (f::MyTranslator)(x, shift) = x - shift;\njulia> a3 = PeriodicArray([1,2,3], MyTranslator());\njulia> a3[0:4]\n5-element PeriodicVector(::Vector{Int64}):\n 4\n 1\n 2\n 3\n 0\njulia> using OffsetArrays\njulia> data = reshape(1:9, 3, 3);\njulia> i = OffsetArray(1:5, -2:2);\njulia> a4 = PeriodicMatrix(data, f);\njulia> a4[i,i]\n5×5 PeriodicArray(OffsetArray(::Matrix{Int64}, -2:2, -2:2)) with indices -2:2×-2:2:\n  1   4   7  11  14\n  2   5   8  12  15\n  3   6   9  13  16\n 11  14  17  21  24\n 12  15  18  22  25","category":"section"},{"location":"#License","page":"Home","title":"License","text":"PeriodicArrays.jl is licensed under the MIT License. By using or interacting with this software in any way, you agree to the license of this software.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
